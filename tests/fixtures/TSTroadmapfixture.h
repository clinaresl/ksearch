// -*- coding: utf-8 -*-
// TSTroadmapfixture.h
// -----------------------------------------------------------------------------
//
// Started on <vie 13-10-2023 13:46:35.758444242 (1697197595)>
// Carlos Linares LÃ³pez <carlos.linares@uc3m.es>
// Ian Herman <iankherman@gmail.com>

//
// Fixture for testing the roadmap_t class
//

#ifndef _TSTROADMAPFIXTURE_H_
#define _TSTROADMAPFIXTURE_H_

#include <algorithm>
#include <cstdlib>
#include <fstream>
#include <map>
#include <random>
#include <string>
#include <utility>
#include <vector>

#include "gtest/gtest.h"

#include "../TSTdefs.h"
#include "../TSThelpers.h"
#include "../../domains/roadmap/roadmap_t.h"

// Class definition
//
// Defines a Google test fixture for testing the graph_t class
class RoadmapFixture : public ::testing::Test {

protected:

    void SetUp () override {

        // just initialize the random seed to make sure that every iteration is
        // performed over different random data
        srand (time (nullptr));
    }

    // given a location in a square grid of length n, return a vector with the
    // ids and cost of accessing every imediatly accessible neighbours under the
    // specified variant ---if unit=true, edge costs are always equal to one;
    // otherwise, they are equal to the sum of the i and j coordinates plus one
    std::vector<std::pair<size_t, int>> get_neighbours (const size_t index, const int n, bool unit=true) {

        // compute the i and j coordinates of this index
        auto i = index % n;
        auto j = index / n;

        // --initialization
        std::vector<std::pair<size_t, int>> output;

        // computation of the edge cost
        int cost = 1;
        if (!unit) {
            cost = 1+i+j;
        }

        // east
        if (i < n-1) {
            output.push_back (std::make_pair (j*n+i+1, cost));
        }

        // west
        if (i > 0) {
            output.push_back (std::make_pair (j*n+i-1, cost));
        }

        // north
        if (j < n-1) {
            output.push_back (std::make_pair ((j+1)*n+i, cost));
        }

        // south
        if (j > 0) {
            output.push_back (std::make_pair ((j-1)*n+i, cost));
        }

        // and return the result
        return output;
    }

    // generate a graph definition file with the format of the 9th DIMACS
    // international competition that represents a square grid of size n. In
    // case "unit" is true, all edges have edge cost equal to 1; otherwise, they
    // take a value which is equal to the sum of the i and j coordinates of the
    // starting vertex plus one. In addition, it populates a map of vertices to
    // coordinats (longitude and latitude) given in radians
    void generate_graph (const std::string& filename, std::map<int, std::pair<double, double>>& coordinates,
                         const int n, bool unit=true) {

            // open the file
            std::ofstream file (filename);

            // write a comment header
            file << "c File automatically generated by libksearch" << std::endl;

            // write the number of vertices
            file << "p aux sp " << n*n << " " << n*n << std::endl;

            // write the edges
            for (auto index = 0 ; index < n*n ; index++) {

                // for every neighbour
                for (const auto& neighbour : get_neighbours(index, n, unit)) {

                    // add the information of this edge
                    file << "a " << index << " " << neighbour.first << " " << neighbour.second << std::endl;
                }

                // and also add its coordinates. The longitude and latitude are
                // divided by a huge number to avoid inconsistencies
                coordinates[index] = std::make_pair(double (index%n)/100'000'000, double (index/n)/100'000'000);
            }

            // close the file
            file.close ();
    }
};

#endif // _TSTROADMAPFIXTURE_H_

// Local Variables:
// mode:cpp
// fill-column:80
// End:
