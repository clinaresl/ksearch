/* 
  KHSnode_t.h
  Description: information of a tree node
  ----------------------------------------------------------------------------- 

  Started on  <Mon Feb 11 00:10:36 2013 Carlos Linares Lopez>
  Last update <martes, 10 mayo 2016 16:18:28 Carlos Linares Lopez (clinares)>
  -----------------------------------------------------------------------------

  $Id::                                                                      $
  $Date::                                                                    $
  $Revision::                                                                $
  -----------------------------------------------------------------------------

  Made by Carlos Linares Lopez
  Login   <carlos.linares@uc3m.es>
*/

#ifndef   	KHSNODE_H_
# define   	KHSNODE_H_

#include <algorithm>
#include <iostream>
#include <iterator>
#include <vector>

namespace khs {

  using namespace std;
  
  template<class T>
  class node_t {
    
  public:
    
    // Explicit constructors
    node_t (const T& state, unsigned int h=0, unsigned int g=0)
      : _state ( state ),
	_h {h},
        _g {g},
        _f {h + g},
        _path {state}
    { }
    
    node_t (const T& state, unsigned int h, unsigned int g, const vector<T>& path)
      : _state ( state ),
	_h (h),
	_g (g),
	_f (h + g),
	_path (path)
    { }
    
    // Copy constructor
    node_t (const node_t& node) = default;
    
    // get accessors
    T get_state () const
    { return _state; }
    T& get_state ()
    { return _state; }
    unsigned int get_h () const
    { return _h; }
    unsigned int get_g () const
    { return _g; }
    unsigned int get_f () const
    { return _f; }
    const vector<T>& get_path () const
    { return _path; }
    
    // set accessors
    void set_state (const T& state)
    { _state = state; }
    void set_h     (unsigned int h)
    { _h = h; }
    void set_g     (unsigned int g)
    { _g = g; }
    void set_f     (unsigned int f)
    { _f = f; }
    
    // method overloading
    node_t& operator=(const node_t& right) = default;
    virtual bool operator< (const node_t& right) const
    { return (_state < right.get_state ());}
    virtual bool operator==(const node_t& right) const
    { return _state == right.get_state ();}
    virtual bool operator!=(const node_t& right) const
    { return !(_state == right.get_state ()); }
    
    // methods

    // next, a state is pushed back to its current path
    void push_back (const T& state)
    { _path.push_back (state); }

    // return true if the given node has been already visited and false
    // otherwise
    bool find (const T& state) const
    { return (std::find (_path.begin (), _path.end (), state) != _path.end ()); }

    // printing services
    friend ostream& operator<< (ostream& stream, node_t node)
    {
      stream << " <" << node.get_state ();
      stream << ", " << node.get_g ();
      stream << " + " << node.get_h ();
      stream << " = " << node.get_f ();
      stream << ">: [";
      
      vector<T> path = node.get_path ();
      copy (path.begin (), path.end (), ostream_iterator<T> (cout, " "));
      cout << "]";
      
      return stream;
    }

  protected:
    
    // Invariant: every node refers to a particular state in a particular domain
    // and thus it stores that information. When been generated by a heuristic
    // search algorithm it is also evaluated and its g-cost, h-estimate and
    // f-cost are computed. Also, every node is generated via a particular
    // path. All nodes are characterized with this information

    // Attributes
    T _state;                                                      // tree node
    unsigned int _h;                                              // h estimate
    unsigned int _g;                                                  // g cost
    unsigned int _f;                                                 // f value
    vector<T> _path;                              // path that led to this node
    
  }; // class node_t<T>
} // namespace khs

#endif 	    /* !KHSNODE_H_ */


/* Local Variables: */
/* mode:c++ */
/* fill-column:80 */
/* End: */
